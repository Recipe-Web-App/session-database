---
# Default values for session-database
# This is a YAML-formatted file.

# Global configuration
global:
  imageRegistry: ""
  storageClass: "standard"

# Image configuration
image:
  registry: ""
  repository: session-database
  tag: "latest"
  pullPolicy: IfNotPresent
  pullSecrets: []

# Deployment mode: standalone, sentinel, cluster
deploymentMode: sentinel

# Redis configuration
redis:
  # Authentication
  auth:
    enabled: true
    password: "${REDIS_PASSWORD}"
    sentinel:
      password: "${SENTINEL_PASSWORD}"

    # ACL users (passwords will be auto-generated if not provided)
    acl:
      app:
        password: ""
      monitor:
        password: ""
      cleanup:
        password: ""
      backup:
        password: ""
      cache:
        password: ""

  # Redis server configuration
  config:
    maxmemory: "1gb"
    maxmemoryPolicy: "allkeys-lru"
    save: "900 1 300 10 60 10000"
    appendonly: true
    timeout: 300
    tcpKeepalive: 300

  # TLS configuration
  tls:
    enabled: false
    port: 6380

# High Availability configuration
ha:
  # Redis Sentinel configuration
  sentinel:
    enabled: true
    replicas: 3
    downAfterMilliseconds: 5000
    failoverTimeout: 10000
    parallelSyncs: 1

    resources:
      requests:
        memory: "128Mi"
        cpu: "100m"
      limits:
        memory: "256Mi"
        cpu: "200m"

  # Redis Master configuration
  master:
    replicas: 1
    persistence:
      enabled: true
      size: "10Gi"
      storageClass: ""

    resources:
      requests:
        memory: "1Gi"
        cpu: "500m"
        ephemeralStorage: "2Gi"
      limits:
        memory: "2Gi"
        cpu: "1000m"
        ephemeralStorage: "4Gi"

  # Redis Replica configuration
  replica:
    replicas: 2
    persistence:
      enabled: false

    resources:
      requests:
        memory: "512Mi"
        cpu: "250m"
        ephemeralStorage: "1Gi"
      limits:
        memory: "1Gi"
        cpu: "500m"
        ephemeralStorage: "2Gi"

# Session management configuration
sessionManagement:
  # Session TTL in seconds
  sessionTTL: 3600

  # Refresh token TTL in seconds (7 days)
  refreshTokenTTL: 604800

  # Maximum sessions per user
  maxSessionsPerUser: 5

  # Maximum refresh tokens per user
  maxRefreshTokensPerUser: 3

  # Cleanup configuration
  cleanup:
    enabled: true
    schedule: "*/5 * * * *"  # Every 5 minutes
    batchSize: 100
    maxExecutionTime: 30

    resources:
      requests:
        memory: "32Mi"
        cpu: "10m"
      limits:
        memory: "64Mi"
        cpu: "50m"

# Service cache configuration
serviceCache:
  # Cache database number (separate from session DB 0)
  database: 1

  # Default cache TTL in seconds (24 hours)
  defaultTTL: 86400

  # Cache key patterns for different service types
  keyPatterns:
    userProfile: "cache:user_profile:{user_id}"
    apiResponse: "cache:api_response:{endpoint}:{params_hash}"
    computation: "cache:computation:{function}:{args_hash}"
    resource: "cache:resource:{resource_type}:{resource_id}"

  # Cache cleanup configuration
  cleanup:
    enabled: true
    schedule: "*/10 * * * *"  # Every 10 minutes
    batchSize: 200
    maxExecutionTime: 45
    # Separate cleanup for different cache types
    strategies:
      lru: true        # Least Recently Used
      ttl: true        # Time To Live based
      manual: true     # Manual cache invalidation

    resources:
      requests:
        memory: "48Mi"
        cpu: "15m"
      limits:
        memory: "96Mi"
        cpu: "75m"

  # Cache-specific configuration
  config:
    # Maximum cache entries per service
    maxEntriesPerService: 10000
    # Cache hit ratio alerting threshold
    hitRatioThreshold: 0.8
    # Memory usage alerting threshold for cache DB
    memoryThreshold: "512Mi"

# Monitoring configuration
monitoring:
  enabled: true

  # Prometheus configuration
  prometheus:
    enabled: true
    replicas: 1
    retention: "200h"
    scrapeInterval: "30s"

    resources:
      requests:
        memory: "512Mi"
        cpu: "200m"
      limits:
        memory: "1Gi"
        cpu: "500m"

  # Grafana configuration
  grafana:
    enabled: true
    replicas: 1
    adminPassword: "${GRAFANA_ADMIN_PASSWORD}"

    resources:
      requests:
        memory: "256Mi"
        cpu: "100m"
      limits:
        memory: "512Mi"
        cpu: "200m"

  # Alertmanager configuration
  alertmanager:
    enabled: true

    resources:
      requests:
        memory: "64Mi"
        cpu: "10m"
      limits:
        memory: "128Mi"
        cpu: "100m"

  # Redis Exporter configuration
  redisExporter:
    enabled: true

    resources:
      requests:
        memory: "32Mi"
        cpu: "10m"
      limits:
        memory: "64Mi"
        cpu: "50m"

# Security configuration
security:
  # Pod Security Standards
  podSecurityStandards:
    enabled: true
    enforce: "restricted"

  # Network Policies
  networkPolicies:
    enabled: true

    # Application namespace/labels that can access Redis
    applicationAccess:
      namespaceSelector:
        matchLabels:
          name: "default"
      podSelector:
        matchLabels:
          component: "application"

  # Service Accounts
  serviceAccount:
    create: true
    automountServiceAccountToken: false
    annotations: {}

# Autoscaling configuration
autoscaling:
  enabled: true
  minReplicas: 1
  maxReplicas: 3
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

# Pod Disruption Budget
podDisruptionBudget:
  enabled: true
  minAvailable: 1

# Node affinity and scheduling
affinity:
  podAntiAffinity: "preferred"
  nodeAffinity: {}

tolerations: []

nodeSelector: {}

# Service configuration
service:
  type: ClusterIP
  port: 6379
  targetPort: 6379

  # Sentinel service
  sentinel:
    type: ClusterIP
    port: 26379
    targetPort: 26379

# Ingress configuration (for monitoring)
ingress:
  enabled: false
  className: ""
  annotations: {}
  prometheusHost: "${INGRESS_PROMETHEUS_HOST}"
  grafanaHost: "${INGRESS_GRAFANA_HOST}"
  tls: []

# Additional environment variables
extraEnvVars: []

# Additional volumes
extraVolumes: []

# Additional volume mounts
extraVolumeMounts: []

# Labels to add to all resources
commonLabels: {}

# Annotations to add to all resources
commonAnnotations: {}

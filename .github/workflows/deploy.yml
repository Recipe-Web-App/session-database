---
name: Deploy

'on':
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - development
          - staging
          - production
      deployment_mode:
        description: 'Deployment mode'
        required: true
        type: choice
        options:
          - standalone
          - ha-sentinel
      helm_values:
        description: 'Helm values file (leave empty for default)'
        required: false
        type: string

  push:
    branches:
      - develop

concurrency:
  group: deploy-${{ github.event.inputs.environment || (github.ref == 'refs/heads/develop' && 'development') }}
  cancel-in-progress: false

permissions:
  contents: read

jobs:
  determine-environment:
    name: Determine Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      deployment_mode: ${{ steps.set-env.outputs.deployment_mode }}
      helm_values: ${{ steps.set-env.outputs.helm_values }}

    steps:
      - name: Set environment
        id: set-env
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            echo "deployment_mode=${{ github.event.inputs.deployment_mode }}" >> $GITHUB_OUTPUT
            echo "helm_values=${{ github.event.inputs.helm_values || 'values.yaml' }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/develop" ]; then
            echo "environment=development" >> $GITHUB_OUTPUT
            echo "deployment_mode=standalone" >> $GITHUB_OUTPUT
            echo "helm_values=values.yaml" >> $GITHUB_OUTPUT
          fi

  validate:
    name: Validate Configuration
    runs-on: ubuntu-latest
    needs: determine-environment

    steps:
      - name: Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6

      - name: Install Helm
        uses: azure/setup-helm@1a275c3b69536ee54be43f2070a358922e12c8d4 # v4
        with:
          version: 'latest'

      - name: Validate Helm chart
        run: |
          helm lint ./helm/redis-database
          helm template redis-database ./helm/redis-database --debug

  deploy:
    name: Deploy to ${{ needs.determine-environment.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [determine-environment, validate]
    environment:
      name: ${{ needs.determine-environment.outputs.environment }}
      url: ${{ steps.get-url.outputs.url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6

      - name: Set up kubectl
        uses: azure/setup-kubectl@776406bce94f63e41d621b960d78ee25c8b76ede # v4
        with:
          version: 'latest'

      - name: Install Helm
        uses: azure/setup-helm@1a275c3b69536ee54be43f2070a358922e12c8d4 # v4
        with:
          version: 'latest'

      - name: Configure kubectl
        env:
          KUBE_CONFIG_DATA: ${{ secrets.KUBE_CONFIG_DATA }}
        run: |
          mkdir -p $HOME/.kube
          echo "$KUBE_CONFIG_DATA" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config

      - name: Set namespace
        id: namespace
        run: |
          NAMESPACE="${{ secrets.KUBE_NAMESPACE }}"
          if [ -z "$NAMESPACE" ]; then
            NAMESPACE="redis-database"
          fi
          echo "namespace=$NAMESPACE" >> $GITHUB_OUTPUT
          echo "Using namespace: $NAMESPACE"

      - name: Create namespace if not exists
        run: |
          kubectl create namespace ${{ steps.namespace.outputs.namespace }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Create Redis secrets
        env:
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          SENTINEL_PASSWORD: ${{ secrets.SENTINEL_PASSWORD }}
        run: |
          kubectl create secret generic redis-database-secret \
            --from-literal=redis-password="${REDIS_PASSWORD}" \
            --from-literal=sentinel-password="${SENTINEL_PASSWORD:-$REDIS_PASSWORD}" \
            --namespace=${{ steps.namespace.outputs.namespace }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy with Helm
        run: |
          VALUES_FILE="${{ needs.determine-environment.outputs.helm_values }}"

          if [ "${{ needs.determine-environment.outputs.deployment_mode }}" = "ha-sentinel" ]; then
            VALUES_FILE="values-production.yaml"
          fi

          helm upgrade --install redis-database ./helm/redis-database \
            --namespace ${{ steps.namespace.outputs.namespace }} \
            --values ./helm/redis-database/${VALUES_FILE} \
            --wait \
            --timeout 10m

      - name: Wait for rollout
        run: |
          if [ "${{ needs.determine-environment.outputs.deployment_mode }}" = "ha-sentinel" ]; then
            kubectl rollout status deployment/redis-master -n ${{ steps.namespace.outputs.namespace }} --timeout=5m
            kubectl rollout status deployment/redis-replica -n ${{ steps.namespace.outputs.namespace }} --timeout=5m
            kubectl rollout status deployment/redis-sentinel -n ${{ steps.namespace.outputs.namespace }} --timeout=5m
          else
            kubectl rollout status deployment/redis-database -n ${{ steps.namespace.outputs.namespace }} --timeout=5m
          fi

      - name: Get deployment URL
        id: get-url
        run: |
          echo "url=Service deployed to namespace ${{ steps.namespace.outputs.namespace }}" >> $GITHUB_OUTPUT

      - name: Display deployment info
        run: |
          echo "=== Deployment Summary ==="
          echo "Environment: ${{ needs.determine-environment.outputs.environment }}"
          echo "Deployment Mode: ${{ needs.determine-environment.outputs.deployment_mode }}"
          echo "Namespace: ${{ steps.namespace.outputs.namespace }}"
          echo ""
          echo "=== Pods ==="
          kubectl get pods -n ${{ steps.namespace.outputs.namespace }}
          echo ""
          echo "=== Services ==="
          kubectl get svc -n ${{ steps.namespace.outputs.namespace }}
          echo ""
          echo "=== PVCs ==="
          kubectl get pvc -n ${{ steps.namespace.outputs.namespace }}

  verify:
    name: Verify Deployment
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy]

    steps:
      - name: Checkout code
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6

      - name: Set up kubectl
        uses: azure/setup-kubectl@776406bce94f63e41d621b960d78ee25c8b76ede # v4
        with:
          version: 'latest'

      - name: Configure kubectl
        env:
          KUBE_CONFIG_DATA: ${{ secrets.KUBE_CONFIG_DATA }}
        run: |
          mkdir -p $HOME/.kube
          echo "$KUBE_CONFIG_DATA" | base64 -d > $HOME/.kube/config
          chmod 600 $HOME/.kube/config

      - name: Set namespace
        id: namespace
        run: |
          NAMESPACE="${{ secrets.KUBE_NAMESPACE }}"
          if [ -z "$NAMESPACE" ]; then
            NAMESPACE="redis-database"
          fi
          echo "namespace=$NAMESPACE" >> $GITHUB_OUTPUT

      - name: Check pod health
        run: |
          echo "Checking pod health..."

          ALL_READY=true

          for deployment in $(kubectl get deployments -n ${{ steps.namespace.outputs.namespace }} -o jsonpath='{.items[*].metadata.name}'); do
            READY_PODS=$(kubectl get deployment $deployment -n ${{ steps.namespace.outputs.namespace }} -o jsonpath='{.status.readyReplicas}')
            DESIRED_PODS=$(kubectl get deployment $deployment -n ${{ steps.namespace.outputs.namespace }} -o jsonpath='{.status.replicas}')

            if [ "$READY_PODS" = "$DESIRED_PODS" ] && [ "$READY_PODS" != "0" ]; then
              echo "‚úÖ $deployment: All pods ready ($READY_PODS/$DESIRED_PODS)"
            else
              echo "‚ùå $deployment: Pods not ready ($READY_PODS/$DESIRED_PODS)"
              ALL_READY=false
            fi
          done

          if [ "$ALL_READY" = "false" ]; then
            kubectl get pods -n ${{ steps.namespace.outputs.namespace }}
            exit 1
          fi

      - name: Test Redis connection
        run: |
          echo "Testing Redis connection..."

          # Get Redis password
          REDIS_PASSWORD=$(kubectl get secret redis-database-secret -n ${{ steps.namespace.outputs.namespace }} -o jsonpath='{.data.redis-password}' | base64 -d)

          # Test Redis ping
          if [ "${{ needs.determine-environment.outputs.deployment_mode }}" = "ha-sentinel" ]; then
            POD_NAME=$(kubectl get pods -n ${{ steps.namespace.outputs.namespace }} -l app=redis-master -o jsonpath='{.items[0].metadata.name}')
          else
            POD_NAME=$(kubectl get pods -n ${{ steps.namespace.outputs.namespace }} -l app=redis-database -o jsonpath='{.items[0].metadata.name}')
          fi

          PING_RESULT=$(kubectl exec -n ${{ steps.namespace.outputs.namespace }} $POD_NAME -- redis-cli -a "$REDIS_PASSWORD" ping)

          if [ "$PING_RESULT" = "PONG" ]; then
            echo "‚úÖ Redis connection successful"
          else
            echo "‚ùå Redis connection failed"
            exit 1
          fi

      - name: Deployment successful
        run: |
          echo "üéâ Deployment to ${{ needs.determine-environment.outputs.environment }} completed successfully!"
